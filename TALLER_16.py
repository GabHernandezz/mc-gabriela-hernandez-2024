# -*- coding: utf-8 -*-
"""TALLER_16ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YND4ipfInSSQzGsltEy62-pfjKQBgG6B

#TALLER 16

##1. Matriz 3x3:

"""
import copy

def imprimirSistema(a, b, etiqueta):
    n = len(b)
    print(etiqueta)
    for i in range(n):
        for j in range(n):
            print(a[i][j], end = " ")
        print("|", b[i])
    print()

def gaussJordan(ao, bo):
    a = copy.deepcopy(ao)
    b = copy.deepcopy(bo)

    n = len(b)
    imprimirSistema(a, b, "Matriz inicial")
    for i in range(n):
        if a[i][i] == 0:
            for fila in range(i+1, n):
                if a[fila][i] != 0:
                    a[fila], a[i] = a[i], a[fila]
                    b[fila], b[i] = b[i], b[fila]
                    break
            imprimirSistema(a, b, "Pivoteo")

        pivote = a[i][i]

        # Dividir por el pivote
        for j in range(n):
            a[i][j] /= pivote
        b[i] /= pivote
        imprimirSistema(a, b, "División")

        # Reducción
        for k in range(n):
            if i != k:
                # Se reduce
                valorAux = -a[k][i]
                for j in range(n):
                    a[k][j] += a[i][j] * valorAux
                b[k] += b[i] * valorAux
        imprimirSistema(a, b, "Reducción")

    return b

#Función de la matriz identidad que crea una matriz de tipo n, donde todos los elementos están definidos como en una matriz identidad
def matrizIdentidad(n):
    return [[1 if i == j else 0 for j in range(n)] for i in range(n)]

# Matriz A
a = [[3, 2, 2], [3, 1, -3], [1, 0, -2]]
n = len(a)
identidad = matrizIdentidad(n)

# Calcular la inversa de A
for i in range(n):
    columna = [fila[i] for fila in identidad]
    resultado = gaussJordan(a, columna)
    for j in range(n):
        identidad[j][i] = resultado[j]

# Imprimir la inversa de A
print("Inversa de la matriz A:")
for fila in identidad:
    print(fila)

"""##1. Matriz 4x4:

"""

import copy

def imprimirSistema(a, b, etiqueta):
    n = len(b)
    print(etiqueta)
    for i in range(n):
        for j in range(n):
            print(a[i][j], end = " ")
        print("|", b[i])
    print()

def gaussJordan(ao, bo):
    a = copy.deepcopy(ao)
    b = copy.deepcopy(bo)

    n = len(b)
    imprimirSistema(a, b, "Matriz inicial")
    for i in range(n):
        if a[i][i] == 0:
            for fila in range(i+1, n):
                if a[fila][i] != 0:
                    a[fila], a[i] = a[i], a[fila]
                    b[fila], b[i] = b[i], b[fila]
                    break
            imprimirSistema(a, b, "Pivoteo")

        pivote = a[i][i]

        # Dividir por el pivote
        for j in range(n):
            a[i][j] /= pivote
        b[i] /= pivote
        imprimirSistema(a, b, "División")

        # Reducción
        for k in range(n):
            if i != k:
                # Se reduce
                valorAux = -a[k][i]
                for j in range(n):
                    a[k][j] += a[i][j] * valorAux
                b[k] += b[i] * valorAux
        imprimirSistema(a, b, "Reducción")

    return b

#Función de la matriz identidad que crea una matriz de tipo n, donde todos los elementos están definidos como en una matriz identidad
def matrizIdentidad(n):
    return [[1 if i == j else 0 for j in range(n)] for i in range(n)]

# Matriz A
a = [[1, 2, 0, 4], [2, 0, -1, -2], [1, 1, -1, 0], [0, 4, 1, 0]]
n = len(a)
identidad = matrizIdentidad(n)

# Calcular la inversa de A
for i in range(n):
    columna = [fila[i] for fila in identidad]
    resultado = gaussJordan(a, columna)
    for j in range(n):
        identidad[j][i] = resultado[j]

# Imprimir la inversa de A
print("Inversa de la matriz A:")
for fila in identidad:
    print(fila)