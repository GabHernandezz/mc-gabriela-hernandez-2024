# -*- coding: utf-8 -*-
"""Untitled18.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-ghyYtekkRm7QxyMWDdBjVQ4gWry6tld

##PROGRAMA REGRESIÓN LINEAL DE POTENCIAS
"""

import numpy as np
import math
import matplotlib.pyplot as plt

def regresion_lineal_potencias(x, y):
    n = len(x)

    log_x = [math.log(x_i) for x_i in x]
    log_y = [math.log(y_i) for y_i in y]

    suma_log_x = sum(log_x)
    suma_log_y = sum(log_y)
    suma_log_xy = sum([log_x[i] * log_y[i] for i in range(n)])
    suma_log_x_cuadrado= sum([log_x_i**2 for log_x_i in log_x])

    beta = (n * suma_log_xy - suma_log_x * suma_log_y) / (n * suma_log_x_cuadrado - suma_log_x**2)
    alpha = math.exp((suma_log_y - beta * suma_log_x) / n)

    return alpha, beta

#Función para mostrar la gráfica de este caso de regresión lineal en potencia
def plot_model(x, y, model, alpha, beta, label):
    plt.scatter(x, y, label='Datos')
    plt.plot(x, [model(alpha, beta, x_i) for x_i in x], color='red', label=label)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.legend()
    plt.grid(True)
    plt.show()

def modelo_depotencias(alpha, beta, x):
    return alpha * x**beta

x = [1, 2, 3, 4, 5, 6, 7, 8]
y = [4.3, 6.5, 7.5, 8, 8.5, 8.8, 9, 9.5]


alpha_potencias, beta_potencias = regresion_lineal_potencias(x, y)
print("Ecuación: y =", alpha_potencias, "* x^", beta_potencias)


plot_model(x, y, modelo_depotencias, alpha_potencias, beta_potencias, 'Modelo de Potencias')

"""##PROGRAMA REGRESIÓN LINEAL A RAZÓN DE CAMBIO"""

import numpy as np
import math
import matplotlib.pyplot as plt


def regresion_lineal_crecimiento(x, y):
    n = len(x)

    inv_x = [1 / x_i for x_i in x]
    inv_y = [1 / y_i for y_i in y]

    sum_inv_x = sum(inv_x)
    sum_inv_y = sum(inv_y)
    sum_inv_xy = sum([inv_x[i] * inv_y[i] for i in range(n)])
    sum_inv_x_squared = sum([inv_x_i**2 for inv_x_i in inv_x])

    beta = (n * sum_inv_xy - sum_inv_x * sum_inv_y) / (n * sum_inv_x_squared - sum_inv_x**2)
    alpha = 1 / (sum_inv_y - beta * sum_inv_x) * n

    return alpha, beta


def plot_model(x, y, model, alpha, beta, label):
    plt.scatter(x, y, label='Datos')
    plt.plot(x, [model(alpha, beta, x_i) for x_i in x], color='red', label=label)
    plt.xlabel('x')
    plt.ylabel('y')
    plt.legend()
    plt.grid(True)
    plt.show()

def modelo_de_crecimiento(alpha, beta, x):
    return alpha / (beta * x + 1)


x = [1, 2, 3, 4, 5, 6, 7, 8]
y = [4.3, 6.5, 7.5, 8, 8.5, 8.8, 9, 9.5]


alpha_crecimiento, beta_crecimiento = regresion_lineal_crecimiento(x, y)
print("Ecuación de Crecimiento: y =", alpha_crecimiento, " / (", beta_crecimiento, "* x + 1)")
plot_model(x, y, modelo_de_crecimiento, alpha_crecimiento, beta_crecimiento, 'Modelo de Crecimiento')

"""##PROGRAMA REGRESIÓN LINEAL, MÍNIMOS CUADRADOS (Modelo exponencial)"""

import numpy as np
import math
import matplotlib.pyplot as plt

def regresion_lineal_a0_a1(x, y):
    n = len(x)

    logaritmon_y = [math.log(y_i) for y_i in y]

    potencia2_x = [x_i**2 for x_i in x]

    producto_xy = [x_i * logaritmon_y[i] for i, x_i in enumerate(x)]


    sum_x = sum(x)
    sum_y = sum(logaritmon_y)
    sum_xy = sum(producto_xy)
    sum_x_squared = sum(potencia2_x)

    a1 = (n * sum_xy - sum_x * sum_y) / (n * sum_x_squared - sum_x**2)
    a0 = (sum_y - a1 * sum_x) / n

    return a0, a1

x = [1, 2, 3, 4, 5, 6, 7, 8]
y = [4.3, 6.5, 7.5, 8, 8.5, 8.8, 9, 9.5]

a0, a1 = regresion_lineal_a0_a1(x, y)
print("La recta de regresión es: y =", a0, "*", "e^(", a1, "x)")


plt.scatter(x, y, label='Datos')
plt.plot(x, [math.exp(a0) * math.exp(a1 * x_i) for x_i in x], color='red', label='Recta de regresión')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.grid(True)
plt.show()

"""##PROGRAMA REGRESIÓN LINEAL POR MÍNIMOS CUADRADOS"""

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import linregress

def producto(lista):
    return [x * x for x in lista]

def cuadrado(lista):
    return [x ** 2 for x in lista]

x = [1, 2, 3, 4, 5, 6, 7, 8]
y = [4.3, 6.5, 7.5, 8, 8.5, 8.8, 9, 9.5]


#Código con uso de numpy y plt

slope, intercept, _, _, _ = linregress(x, y)


x_regresion = np.linspace(min(x), max(x), 100)
y_regresion = slope * x_regresion + intercept


plt.scatter(x, y, label='Datos originales')
plt.plot(x_regresion, y_regresion, color='red', label='Regresión lineal')
plt.xlabel('X')
plt.ylabel('Y')
plt.legend()
plt.grid(True)
plt.show()