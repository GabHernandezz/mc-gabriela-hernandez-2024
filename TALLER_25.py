# -*- coding: utf-8 -*-
"""TALLER_25.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l02dq3sgP_eLrPSGgZcwP-2DhGo6PS7s

#TALLER 24
Comparación de Interpolaciones usando el ejercicio del taller pasado
"""

import numpy as np
import matplotlib.pyplot as plt

def multiplicar_polinomios(a, b):
    longitud = len(a) + len(b) - 1
    resultado = [0] * longitud

    for i in range(len(a)):
        for j in range(len(b)):
            resultado[i + j] += a[i] * b[j]
    return resultado

def imprimir_polinomio(p):
    texto = 'f(x) = '
    grado = len(p) - 1
    for i in range(len(p)):
        if p[i] == 0:
            continue
        if i > 0 and p[i] >= 0:
            texto += '+'
        texto += str(round((p[i]), 6))
        if grado == 1:
            texto += 'x'
        elif grado > 1:
            texto += 'x^' + str(grado)
        grado -= 1
    print(texto)
    return texto

# Programa principal
x = [1, 2, 3, 4, 5]
y = [2, 1.8, -2, -4.6, 3.6]

n = len(x)
polinomio = [0] * n
for i in range(n):
    numerador = [1]
    denominador = 1
    for j in range(n):
        if j != i:
            numerador = multiplicar_polinomios(numerador, [1, -x[j]])
            denominador = denominador * (x[i] - x[j])
    lixfxi = []
    for k in range(len(numerador)):
        lixfxi.append(numerador[k] / denominador * y[i])

    for k in range(len(lixfxi)):
        polinomio[k] += lixfxi[k]

print("Polinomio de Lagrange:")
polinomio_texto = imprimir_polinomio(polinomio)

def evaluar_polinomio(p, x):
    resultado = 0
    for coef in p:
        resultado = resultado * x + coef
    return resultado


x_range = np.linspace(min(x), max(x), 500)
y_lagrange = [evaluar_polinomio(polinomio, xi) for xi in x_range]


plt.plot(x, y, 'o', label='Datos')
plt.plot(x_range, y_lagrange, label='Polinomio de Interpolación de Lagrange')
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Interpolación de Lagrange')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

def multiplicar_polinomios(a, b):
    longitud = len(a) + len(b) - 1
    resultado = [0] * longitud

    for i in range(len(a)):
        for j in range(len(b)):
            resultado[i + j] += a[i] * b[j]
    return resultado

def imprimir_polinomio(p):
    texto = 'f(x) = '
    grado = len(p) - 1
    for i in range(len(p)):
        if p[i] == 0:
            continue
        if i > 0 and p[i] >= 0:
            texto += '+'
        texto += str(round((p[i]), 6))
        if grado == 1:
            texto += 'x'
        elif grado > 1:
            texto += 'x^' + str(grado)
        grado -= 1
    print(texto)

x = [1, 2, 3, 4, 5]
y = [2, 1.8, -2, -4.6, 3.6]

cs = CubicSpline(x, y, bc_type='natural')
x_est = 3.55
f_cubic = cs(x_est)
print(f"Valor estimado de f(3.55) usando Trazadores Cúbicos: {f_cubic}")
x_range = np.linspace(min(x), max(x), 500)
y_cubic = cs(x_range)

plt.plot(x, y, 'o', label='Datos')
plt.plot(x_range, y_cubic, label='Trazadores Cúbicos')
plt.axvline(x=x_est, color='r', linestyle='--', label=f'x = {x_est}')
plt.axhline(y=f_cubic, color='g', linestyle='--', label=f'f({x_est}) = {f_cubic:.6f}')
plt.legend()
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Interpolación mediante Trazadores Cúbicos')
plt.show()

"""#TALLER 25


"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import CubicSpline

def multiplicar_polinomios(a, b):
    longitud = len(a) + len(b) - 1
    resultado = [0] * longitud

    for i in range(len(a)):
        for j in range(len(b)):
            resultado[i + j] += a[i] * b[j]
    return resultado

def imprimir_polinomio(p):
    texto = 'f(x) = '
    grado = len(p) - 1
    for i in range(len(p)):
        if p[i] == 0:
            continue
        if i > 0 and p[i] >= 0:
            texto += '+'
        texto += str(round((p[i]), 6))
        if grado == 1:
            texto += 'x'
        elif grado > 1:
            texto += 'x^' + str(grado)
        grado -= 1
    print(texto)
    return texto

# Datos
x = [1, 2, 3, 4, 5, 6, 7]
y = [1, 5, 4, 4, -2, 2, 9]

# Interpolación de Lagrange
n = len(x)
polinomio = [0] * n
for i in range(n):
    numerador = [1]
    denominador = 1
    for j in range(n):
        if j != i:
            numerador = multiplicar_polinomios(numerador, [1, -x[j]])
            denominador = denominador * (x[i] - x[j])
    lixfxi = []
    for k in range(len(numerador)):
        lixfxi.append(numerador[k] / denominador * y[i])

    for k in range(len(lixfxi)):
        polinomio[k] += lixfxi[k]

print("Polinomio de Lagrange:")
polinomio_texto = imprimir_polinomio(polinomio)


def evaluar_polinomio(p, x):
    resultado = 0
    for coef in p:
        resultado = resultado * x + coef
    return resultado

x_est = 3.55
f_lagrange = evaluar_polinomio(polinomio, x_est)
print(f"Valor estimado de f(3.55) usando Lagrange: {f_lagrange}")

# Gráfica del polinomio por interpolacion de Lagrange
x_range = np.linspace(min(x), max(x), 500)
y_lagrange = [evaluar_polinomio(polinomio, xi) for xi in x_range]

plt.plot(x, y, 'o', label='Datos')
plt.plot(x_range, y_lagrange, label='Lagrange')
plt.legend()
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Interpolación de Lagrange')
plt.show()

# Interpolación mediante Trazadores Cúbicos
cs = CubicSpline(x, y, bc_type='natural')

f_cubic = cs(x_est)
print(f"Valor estimado de f(3.55) usando Trazadores Cúbicos: {f_cubic}")

# Gráfica del trazador cúbico
y_cubic = cs(x_range)

plt.plot(x, y, 'o', label='Datos')
plt.plot(x_range, y_cubic, label='Trazadores Cúbicos')
plt.legend()
plt.xlabel('x')
plt.ylabel('f(x)')
plt.title('Interpolación mediante Trazadores Cúbicos')
plt.show()