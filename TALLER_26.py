# -*- coding: utf-8 -*-
"""TALLER_26.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12zDGhGVbNd7wYYRR8mBDWMK8aDQ_dxN-
"""

class Nodo:
    def __init__(self, clave):
        self.izquierdo = None
        self.derecho = None
        self.valor = clave

class ArbolBinarioBusqueda:
    def __init__(self):
        self.raiz = None

    def insertar(self, clave):
        if self.raiz is None:
            self.raiz = Nodo(clave)
        else:
            self._insertar(self.raiz, clave)

    def _insertar(self, nodo, clave):
        if clave < nodo.valor:
            if nodo.izquierdo is None:
                nodo.izquierdo = Nodo(clave)
            else:
                self._insertar(nodo.izquierdo, clave)
        else:
            if nodo.derecho is None:
                nodo.derecho = Nodo(clave)
            else:
                self._insertar(nodo.derecho, clave)

    def recorrido_inorden(self, nodo):
        if nodo:
            self.recorrido_inorden(nodo.izquierdo)
            print(nodo.valor, end=' ')
            self.recorrido_inorden(nodo.derecho)

# Creación del árbol de búsqueda binaria con el conjunto A
A = [22, 15, 1, 12, 4, 20, 13, 30, 18, 5, 6, 29, 11, 27, 7, 28, 10, 14, 21, 2, 19, 3]
abb = ArbolBinarioBusqueda()
for elemento in A:
    abb.insertar(elemento)

# Imprimir el árbol en orden
print("Recorrido en orden del Arbol Binario de Búsqueda:")
abb.recorrido_inorden(abb.raiz)
print()

class Nod_arbolb:
    def __init__(self, t, hoja=False):
        self.t = t  # Este define el rango para el número de claves
        self.hoja = hoja  # Es true si es nodo hoja, si no es False
        self.claves = []  # Lista de claves en los nodos
        self.hijos = []  # Lista de hijos de los nodos

class ArbolB:
    def __init__(self, t):
        self.raiz = Nod_arbolb(t, True)
        self.t = t  # Grado mínimo

    def insertar(self, k):
        raiz = self.raiz
        if len(raiz.claves) == (2 * self.t) - 1:
            temp = Nod_arbolb(self.t, False)
            self.raiz = temp
            temp.hijos.insert(0, raiz)
            self._dividir_hijo(temp, 0)
            self._insertar_no_lleno(temp, k)
        else:
            self._insertar_no_lleno(raiz, k)

    def _insertar_no_lleno(self, x, k):
        i = len(x.claves) - 1
        if x.hoja:
            x.claves.append(0)
            while i >= 0 and k < x.claves[i]:
                x.claves[i + 1] = x.claves[i]
                i -= 1
            x.claves[i + 1] = k
        else:
            while i >= 0 and k < x.claves[i]:
                i -= 1
            i += 1
            if len(x.hijos[i].claves) == (2 * self.t) - 1:
                self._dividir_hijo(x, i)
                if k > x.claves[i]:
                    i += 1
            self._insertar_no_lleno(x.hijos[i], k)

    def _dividir_hijo(self, x, i):
        t = self.t
        y = x.hijos[i]
        z = Nod_arbolb(t, y.hoja)
        x.hijos.insert(i + 1, z)
        x.claves.insert(i, y.claves[t - 1])
        z.claves = y.claves[t:(2 * t) - 1]
        y.claves = y.claves[0:t - 1]
        if not y.hoja:
            z.hijos = y.hijos[t:2 * t]
            y.hijos = y.hijos[0:t]

    def imprimir_arbol(self, x, nivel=0):
        print("Nivel", nivel, " ", len(x.claves), "claves:", x.claves)
        nivel += 1
        if len(x.hijos) > 0:
            for hijo in x.hijos:
                self.imprimir_arbol(hijo, nivel)


arbol_b = ArbolB(5)
for elemento in A:
    arbol_b.insertar(elemento)

# Imprimir el árbol
print("Estructura del Árbol B:")
arbol_b.imprimir_arbol(arbol_b.raiz)